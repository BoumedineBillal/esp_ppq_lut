/*
 * Hardware-Exact LUT Validation App
 * * Objective: Confirm that the ESP32-P4 Hardware execution of an INT16 LUT
 * is 100% BIT-EXACT to the Python Simulation (HardwareLUT).
 *
 * Key Requirement:
 * - Both Hardware and Simulator must use Round-Half-To-Even (RNE).
 * - Simulator uses `.round()`.
 * - Hardware MUST use `dl::tool::round()`.
 */

#include <stdio.h>
#include <string.h>
#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "nvs_flash.h"
#include "esp_log.h"

// ------------------------------------------------------------------
// ESP-DL Includes
// ------------------------------------------------------------------
#include "dl_model_base.hpp" 
#include "dl_tensor_base.hpp"
#include "dl_tool.hpp" // CRITICAL: For official dl::tool::round (P4 RNE behavior)

// ------------------------------------------------------------------
// Generated Test Data Include
// ------------------------------------------------------------------
// This file is generated by the Python script (validate_lut.py).
// It contains:
//   - input_data[]: The raw float inputs used in simulation.
//   - expected_output[]: The expected quantized float outputs from simulation.
#include "test_data.h" 

static const char *TAG = "LUT_VALIDATION";

// ------------------------------------------------------------------
// Embedded Model Symbols
// ------------------------------------------------------------------
// These symbols are automatically generated by the linker when using 
// `target_add_aligned_binary_data` in CMakeLists.txt.
extern const uint8_t model_binary_start[] asm("_binary_swish_lut_test_espdl_start");

// Note: _end symbol is unused in modern dl::Model constructor, avoiding unused warning.


extern "C" void app_main(void)
{
    ESP_LOGI(TAG, "==========================================================");
    ESP_LOGI(TAG, "   Starting Hardware-Exact LUT Validation");
    ESP_LOGI(TAG, "   Goal: 0 Mismatches between Sim and HW");
    ESP_LOGI(TAG, "==========================================================");

    // ------------------------------------------------------------------
    // 1. Load Model from Flash
    // ------------------------------------------------------------------
    dl::Model *model = new dl::Model((const char *)model_binary_start, 
                                     fbs::MODEL_LOCATION_IN_FLASH_RODATA,
                                     0, dl::MEMORY_MANAGER_GREEDY,
                                     nullptr, true);
    
    if (!model) {
        ESP_LOGE(TAG, "Failed to load model!");
        return;
    }

    // ------------------------------------------------------------------
    // 2. Prepare Input Tensor
    // ------------------------------------------------------------------
    std::map<std::string, dl::TensorBase *> inputs = model->get_inputs();
    dl::TensorBase *input_tensor = inputs.begin()->second; // We have only 1 input
    
    // Safety Checks
    if (input_tensor->dtype != dl::DATA_TYPE_INT16) {
        ESP_LOGE(TAG, "CRITICAL ERROR: Model Input is NOT INT16! (Type: %d)", input_tensor->dtype);
        return;
    }
    ESP_LOGI(TAG, "Input Exponent: %d", input_tensor->exponent);


    // ------------------------------------------------------------------
    // 3. Inject Test Data (CRITICAL STEP)
    // ------------------------------------------------------------------
    // We must quantize the float inputs EXACTLY as the Simulator did.
    //
    // Simulator used: (val / scale).round().clamp(...)
    // Hardware used:  dl::tool::round(val / scale).clamp(...)
    //
    // On ESP32-P4, dl::tool::round uses the `fcvt.w.s ... rne` instruction.
    // RNE = Round to Nearest, Ties to Even.
    // This perfectly matches PyTorch's default behavior.
    
    float scale = powf(2.0f, input_tensor->exponent);
    int16_t *input_ptr = (int16_t *)input_tensor->data;
    
    std::map<std::string, dl::TensorBase *> outputs = model->get_outputs();
    dl::TensorBase *output_tensor = outputs.begin()->second;
    int16_t *output_ptr = (int16_t *)output_tensor->data;
    float out_scale = powf(2.0f, output_tensor->exponent);

    int chunk_size = input_tensor->size;
    int num_chunks = input_data_len / chunk_size;
    
    ESP_LOGI(TAG, "Input Exponent: %d | Output Exponent: %d", input_tensor->exponent, output_tensor->exponent);
    ESP_LOGI(TAG, "Processing %d chunks of size %d (Total: %d)...", num_chunks, chunk_size, input_data_len);
    
    int global_fail_count = 0;
    float global_max_diff = 0.0f;
    long total_inference_time = 0;

    for (int c = 0; c < num_chunks; c++) {
        // 1. Inject Chunk
        for (int i = 0; i < chunk_size; i++) {
            int g_idx = c * chunk_size + i;
            float val = input_data[g_idx] / scale;
            int rounded_val = dl::tool::round(val);
            if (rounded_val > 32767) rounded_val = 32767;
            if (rounded_val < -32768) rounded_val = -32768;
            input_ptr[i] = (int16_t)rounded_val;
        }

        // 2. Run Inference
        long start_time = esp_timer_get_time();
        model->run();
        total_inference_time += (esp_timer_get_time() - start_time);

        // 3. Verify Chunk
        for (int i = 0; i < chunk_size; i++) {
            int g_idx = c * chunk_size + i;
            float hw_val = output_ptr[i] * out_scale;
            float sim_val = expected_output[g_idx];
            
            float diff = fabsf(hw_val - sim_val);
            if (diff > global_max_diff) global_max_diff = diff;

            int16_t sim_int = (int16_t)roundf(sim_val / out_scale);
            if (output_ptr[i] != sim_int) {
                if (global_fail_count < 10) {
                    ESP_LOGE(TAG, "MISMATCH at Chunk %d, Idx %d (Global %d): HW=%d vs Sim=%d | In=%f", 
                             c, i, g_idx, output_ptr[i], sim_int, input_data[g_idx]);
                }
                global_fail_count++;
            }
        }

        if ((c + 1) % 10 == 0 || c == num_chunks - 1) {
            ESP_LOGI(TAG, "Progress: %d/%d chunks verified...", c + 1, num_chunks);
        }
    }

    ESP_LOGI(TAG, "Total Inference Time: %ld us (Avg: %ld us/chunk)", total_inference_time, total_inference_time / num_chunks);
    
    ESP_LOGI(TAG, "==========================================================");
    if (global_fail_count == 0) {
        ESP_LOGI(TAG, "\033[32m✅ SUCCESS: Hardware result matches Simulation 100%%\033[0m");
        ESP_LOGI(TAG, "Max Float Diff: %f", global_max_diff);
        ESP_LOGI(TAG, "Constraint Verified: Exhaustive 65k Sweep is BIT-EXACT.");
    } else {
        ESP_LOGE(TAG, "\033[31m❌ FAILURE: Found %d mismatches.\033[0m", global_fail_count);
        ESP_LOGE(TAG, "Please check Rounding Mode or Interpolation Logic.");
    }
    ESP_LOGI(TAG, "==========================================================");

    // Cleanup
    delete model;
}